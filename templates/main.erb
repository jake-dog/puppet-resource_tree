<%# We need to create a clean scope to evaluate any strings -%>
<%# Variable collisions only seem to effect jruby. -%>
<%# Since we're resetting scope, we also add some convenience -%>
<%# methods, like hiera, hiera_hash, without the function_* -%>
<%# aliases.  We cannot use alias_method, nor do we support -%>
<%# ruby 1.8.7, so "scope" is passed in to preserve compatibility -%>
<%# with unaliased methods. Instance variables are also copied -%>
<%# over from scope, much like Puppet::Parser::TemplateWrapper. -%>
<%
  class CleanScope
    def scope_call(*params)
      scope.method(:"function_#{__callee__}").call(params)
    end

    define_method "hiera", instance_method(:scope_call)
    define_method "hiera_hash", instance_method(:scope_call)
    define_method "hiera_array", instance_method(:scope_call)

    def scope_eval(code)
      if !@clientcert
        scope.to_hash.each do |name, value|
          realname = name.gsub(/[^\w]/, "_")
          instance_variable_set("@#{realname}", value)
        end
      end

      instance_eval(code)
    end
    def initialize(scope)
      @__scope__ = scope
    end
    def scope
      @__scope__
    end
  end
  clean = CleanScope.new scope
-%>

<%# Reject collections that are not in resource_tree::apply -%>
<%
  apply_collections = @allcollections.reject {|k,v|
    !(@allapply.include? k)
  }
-%>

<%# Evaluate any collections whose value is a string, -%>
<%# returning only the resulting collections. -%>
<%
  parsed_collections = apply_collections.map{|k,v|
    ((v.to_s == v) && clean.scope_eval(v)) || v
  }
-%>

<%# Deep merge first level of collections, -%>
<%# evaluating any resource types whose value is a string -%>
<%
  resources = parsed_collections.inject({}) {|a,b|
    a.merge(Hash[(a.keys & b.keys).map {|k| 
      [k,(((a[k].to_s == a[k]) && clean.scope_eval(a[k])) || a[k]).merge(((b[k].to_s == b[k]) && clean.scope_eval(b[k])) || b[k])] 
    }]).merge(b.reject {|k,v| 
      (a.keys & b.keys).include? k 
    })
  }
-%>

<%# Evaluate individual resources whose value is a string, -%>
<%# while reformatting each in resource_tree::resource syntax -%>
<%
  resources_by_type = resources.map {|k,v|
    Hash[(((v.to_s == v) && clean.scope_eval(v)) || v).map {|a,b| 
      [a, (((b.to_s == b) && clean.scope_eval(b)) || b)] 
    }.map {|a,b| 
      [ k+"-"+a,
        {
          "type" => k, 
          "rt_notify" => b.fetch("rt_notify",nil), 
          "rt_requires" => b.fetch("rt_requires",nil), 
          "rt_resources" => b.fetch("rt_resources",nil),
          "params" => {
            a => @defaults.fetch(k,{}).merge(b.reject {|x,y|
              ["rt_resources", "rt_requires", "rt_notify"].include? x 
            })
          }
        }
      ]
    }]
  }
-%>

<%# Merge hash of resources by type into a single -%>
<%# hash of resource_tree::resource objects -%>
<%=
  resources_by_type.flatten(1).inject({}) {|a,b|
    a.merge(b)
  }.to_yaml
%>